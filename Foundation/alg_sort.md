# 算法--排序篇
复习以下排序算法。先介绍常见的非线性排序算法，具体实现在相应小结链接中。这部分介绍不会像网上哪样长篇大论叙述原理，主要还是督促自己动手写一遍。结果比想象中花的时长很多（果然还是菜）。
第二部分介绍非线性时间排序，这部分代码没有实现，文字描述会稍微多点。
第三部分总结，给出所有排序算法的小总结。

##  非线性时间排序算法
比较通用的排序算法

### 冒泡排序
见[代码](./demo/algorithm/sort/bubble.cpp)

### 选择排序
见[代码](./demo/algorithm/sort/choose.cpp)

### 插入排序
见[代码](./demo/algorithm/sort/insert.cpp)

### 堆排序
记住主要步骤：  
- 建大根堆
- 维护大根堆性质
- 递归调用

见[代码](./demo/algorithm/sort/heap.cpp)

### 归并排序
记住关键步骤：  
- 划分区间（二分）
- 合并排序好的区间

> 注意动态分配内存，思路是自底向上

见[代码](./demo/algorithm/sort/merge.cpp)

### 快速排序
记住关键步骤：  
- 区间划分（根据选取的参考值）
- 递归调用

> 注意区间划分值最后划分后的位置，充分考虑到各种case，思路是自顶向下

见[代码](./demo/algorithm/sort/quick.cpp)

## 线性时间排序算法
线性时间排序，这部分的排序算法不具备通用性，往往是针对特定结构的数据进行排序。

### 计数排序
假设n个输入元素中的每一个数严格包含在\[0,k\]区间内，且满足$k=O(n)$， 对这n个数的排序，时间复杂度为$\Theta(n+k)$.

思想：  
输入的n个数,长度为k的辅助数组统计每个元素出现的次数，再依次输出即可。
### 基数排序
假设n个d位数，其中每一个数位都有k种取值。排序的时间复杂度为$\Theta(d(n+k))$.

思路：  
对n个数按照从低位到高位，对每一位进行排序，最高位排完后即是最终结果。对每一位的排序所需的时间复杂度为$\Theta(n+k)$, 每一个数有d位，所以总的时间复杂度为$\Theta(d(n+k))$

### 桶排序
假设n个数均匀的分布在\[a,b\]区间内，将\[a,b\]区间均匀的分成k个桶，那么对这n个数排序的时间复杂度为$\Theta(n+k)$

思路：  
将n个元素分别放入到对应的区间的桶中，再对桶内的数据进行排序，也可以采用链表的形式输入的时候已经排好序。再按照桶的顺序依次输出桶内元素。
## 总结

非线性时间排序算法

排序方法 | 时间复杂度(最好) | 时间复杂度（平均） | 时间复杂度（最坏） | 额外空间复杂度 | 稳定性
--- | --- | --- | --- | --- | --- 
冒泡排序 | $O(n^2)$ | $O(n^2)$ | $O(n^2)$ | O(1) | 稳定
选择排序 | $O(n^2)$ | $O(n^2)$ | $O(n^2)$ | O(1) | 不稳定
插入排序 | $O(n^2)$ | $O(n^2)$ | $O(n^2)$ | O(1) | 稳定
堆排序 | $O(nlogn)$ | $O(nlogn)$ | $O(nlogn)$ | O(1) | 不稳定
归并排序 | $O(nlogn)$ | $O(nlogn)$ | $O(nlogn)$ | O(n) | 稳定
快速排序 | $O(nlogn)$ | $O(nlogn)$ | $O(n^2)$ | O(1) | 不稳定

线性时间排序算法

> 线性时间排序算法对数据的范围和结构有特定的要求，如果考虑最坏和最好情况觉得没有意义，故这里只讨论平均复杂度

排序方法 | 时间复杂度（平均） | 额外空间复杂度 | 稳定性
--- | --- | --- | --- 
计数排序 | $\Theta(n+k)$ | O(k) | 稳定
基数排序 | $\Theta(d(n+k))$ | O(1) | 稳定
桶排序 | $\Theta(n+k)$ | O(n+k) | 稳定
