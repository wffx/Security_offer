# 算法-图论基础

本篇主要介绍图论的基础，深度优先遍历和广度优先遍历。

## 图的表示

图在实际编程中有很多种实现，主要还是分成两类：一类是临接链表；第二类是临接矩阵；
前者，比较适合单向图，边比较稀疏的情况；后者，适用于双向图，边比较稠密的情况，存储开销也会更大。

在我的[demo](./demo/algorithm/graph_base)中，我采用类似与临接链表的实现方式，用一个结构体表示节点，和该节点所连接的边。这里边用的是vector存储，比链表的形式操作会更加方便。

## 深度优先遍历

注意的地方：
  
- 递归的终止条件
- 递归回溯时保存的路径需要弹出

[demo](./demo/algorithm/graph_base/DFS.cpp)

## 广度优先遍历

注意的地方：

- 采用队列保存待访问节点，如果需要剪枝或者限界的话可以考虑使用优先队列
- 保存路径的时候，我这里在储存队列的时候封装了到当前节点的路径vector

[demo](./demo/algorithm/graph_base/BFS.cpp)

## 拓扑排序
拓扑排序需要满足以下条件：

- 存在边(u,v)则u点一定在v点之前
- 图中没有环路

思路： 
- 将入度为0的节点入队列中
- 输出队首元素，并将该节点标记已访问，去除连接该节点的所有边
- 再将剩余节点中入度为0的节点加入队列，重复1-2过程直到队列为空，或所有节点已访问

[demo](./demo/algorithm/graph_tupo_sort)
